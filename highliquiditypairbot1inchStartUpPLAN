import dotenv from 'dotenv';
import axios from 'axios';
import Web3 from 'web3';
import BigNumber from 'bignumber.js';
import PQueue from 'p-queue';
import retry from 'async-retry';
import PriorityQueue from 'priorityqueuejs'; // Import a priority queue library
import { AllowanceTransfer } from '@uniswap/permit2'; // Import Permit2 SDK
import pkg from 'telegraf';
import { ethers } from 'ethers';
import { createRequire } from 'module'; 

dotenv.config();

if (!process.env.CONTRACT_ADDRESS || !process.env.PERMIT2_ADDRESS || !process.env.INFURA_URL || 
    !process.env.TELEGRAM_BOT_TOKEN || !process.env.BLOCKNATIVE_API_KEY || !process.env.ONEINCH_API_KEY) {
    throw new Error("Missing critical environment variables.");
}

const web3 = new Web3(process.env.INFURA_URL); // Ensure this is Arbitrum-compatible
const HEADERS = {
  headers: {
    Authorization: `Bearer ${process.env.ONEINCH_API_KEY}`,
  },
};
const { Telegraf } = pkg;
const require = createRequire(import.meta.url);
//const interval = Math.max(1000, Math.ceil(1000 / (10 - currentRequestCount)));
const dynamicInterval = Math.ceil(1000 / (10 - requestCount));
apiQueue.interval = Math.max(dynamicInterval, 100); // At least 100ms between requests

// Constants
const CAPITAL = new BigNumber(100000).shiftedBy(6); // $100,000 in usdc (6 decimals)
const MIN_PROFIT_THRESHOLD = new BigNumber(20).shiftedBy(6); // $20 minimum profit
const MAX_HOPS = 3;
const PATHFINDER_API_URL = "https://api.1inch.dev/swap/v6.0/42161"; // Arbitrum network
const ONEINCH_BASE_URL = "https://api.1inch.dev";
const SWAP_API_URL = `${ONEINCH_BASE_URL}/swap/v6.0`;
const TOKEN_API_URL = `${ONEINCH_BASE_URL}/token/v1.2/42161/custom`;
const PRICE_API_URL = `${ONEINCH_BASE_URL}/price/v1.1`;
const HISTORY_API_URL = `${ONEINCH_BASE_URL}/history/v2.0/history`;
//const STABLE_TOKENS = ["usdc", ""usdt","dai", "weth", "wbtc"];
const STABLE_TOKENS = ["usdc", "usdt", "dai", "weth", "wbtc"]; // Fixed syntax error
const chainId = 42161;
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS;
const liquidityCache = {}; // Initialize at the module level to persist cache across calls
const ABI = require('./YourContractABI.json');
const contract = new web3.eth.Contract(ABI, CONTRACT_ADDRESS);
const flashLoanRate = 0.0009; // Default to 0.09%
const flashLoanFee = (amount) => amount.multipliedBy(flashLoanRate);

const dynamicThreshold =  (amount, gasCost) => {
  const fee = flashLoanFee(amount);
  return MIN_PROFIT_THRESHOLD.plus(gasCost).plus(fee);
};

const potentialProfit = toPrice.minus(fromPrice);
const threshold = dynamicThreshold(amount, gasCost);
if (potentialProfit.isGreaterThan(threshold)) {
    routes.push(newPath);
}


const metrics = {
    successfulTrades: 0,
    skippedRoutes: 0,
    totalProfit: new BigNumber(0),
};


async function safeExecute(fn, onError) {
    try {
        return await fn();
    } catch (error) {
        console.error("Error:", error.message);
        if (onError) await onError(error);
    }
}

function logMetrics() {
    console.log(`Metrics:
    - Successful Trades: ${metrics.successfulTrades}
    - Skipped Routes: ${metrics.skippedRoutes}
    - Total Profit: $${metrics.totalProfit.dividedBy(1e6).toFixed(2)}`);
}
setInterval(logMetrics, 60000);

setInterval(async () => {
    const message = `📊 *Execution Summary*:
    - Successful Trades: ${metrics.successfulTrades}
    - Skipped Routes: ${metrics.skippedRoutes}
    - Total Profit: $${metrics.totalProfit.dividedBy(1e6).toFixed(2)}`;
    await sendTelegramMessage(message);
}, 3600000); // Every hour

let requestCount = 0;
setInterval(() => {
    console.log(`Requests in the last second: ${requestCount}`);
    requestCount = 0; // Reset counter
}, 1000);


async function fetchWithRetry(url, options) {
    return retry(
        async (bail, attempt) => {
            try {
                const response = await axios.get(url, options);

                if (response.status !== 200) {
                    throw new Error(`API call failed with status ${response.status}`);
                }

                console.log(`Fetch successful on attempt ${attempt}: ${url}`);
                return response.data;
            } catch (error) {
                // If it's a non-retryable error, bail out
                if (error.response && [400, 403, 404].includes(error.response.status)) {
                    console.error(`Non-retryable error for ${url}:`, error.message);
                    bail(error); // Prevent retry
                    return; // Return to satisfy function signature
                }

                console.warn(`Retrying ${url} due to error:`, error.message);
                throw error; // Retry for other errors
            }
        },
        {
            retries: 5, // Number of retries
            minTimeout: 1000, // Minimum wait time (1 second)
            maxTimeout: 8000, // Maximum wait time (8 seconds)
            factor: 2, // Exponential backoff factor
            onRetry: (error, attempt) => {
                console.warn(`Retry attempt ${attempt} for ${url}. Error: ${error.message}`);
            },
        }
    );
}


// API Call Queue
const apiQueue = new PQueue({
    concurrency: 10, // Max 10 requests in parallel
    interval: 1000,  // 1-second interval
    intervalCap: 10, // Maximum 10 requests per second
});


// Caching
const cache = new Map();

function getCachedData(key) {
  const data = cache.get(key);
  if (data && Date.now() - data.timestamp < 60000) return data.value; // Cache for 60 seconds
  return null;
}

function fetchWithCache(key, fetchFn) {
    const cached = getCachedData(key);
    if (cached) return Promise.resolve(cached);

    return fetchFn().then((data) => {
        setCachedData(key, data);
        return data;
    });
}

function setCachedData(key, value) {
  cache.set(key, { value, timestamp: Date.now() });
}

// Telegram Notifications
async function sendTelegramMessage(message) {
    const timestamp = new Date().toISOString();
    try {
        await axios.post(
            `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`,
            {
                chat_id: process.env.TELEGRAM_CHAT_ID,
                text: `[${timestamp}] ${message}`,
                parse_mode: "Markdown",
            }
        );
        console.log("Telegram notification sent.");
    } catch (error) {
        console.error("Failed to send Telegram message:", error.message);
    }
}


// Fetch Gas Price
async function fetchGasPrice() {
  try {
    // Fetch gas price from Blocknative API
    const response = await axios.get(
      "https://api.blocknative.com/gasprices/blockprices",
      {
        headers: { Authorization: `Bearer ${process.env.BLOCKNATIVE_API_KEY}` },
        params: { chainId: 42161 },
      }
    );

    // Return the recommended gas price in Wei
    return new BigNumber(response.data.blockPrices[0].estimatedPrices[0].price).shiftedBy(9); // Gwei to Wei
  } catch (error) {
    console.error("Failed to fetch gas price from Blocknative API:", error.message);

    try {
      // Fallback to the median gas price from the last N blocks
      const gasFallback = await web3.eth.getGasPrice(); // Get current gas price from the network
      console.log(`Using network fallback gas price: ${gasFallback} Wei`);
      return new BigNumber(gasFallback);
    } catch (fallbackError) {
      console.error("Failed to fetch gas price from network:", fallbackError.message);

      // Fallback to a default gas price if all else fails
      const defaultGasPrice = new BigNumber(50).shiftedBy(9); // 50 Gwei
      console.log(`Using default fallback gas price: ${defaultGasPrice.toString()} Wei`);
      return defaultGasPrice;
    }
  }
}


/**
 * Fetch token prices from 1inch Price API using batching.
 * Integrates caching and dynamic fetching for efficiency.
 */
async function fetchTokenPrices(tokenAddresses) {
    if (!Array.isArray(tokenAddresses) || tokenAddresses.length === 0) {
        throw new Error("Invalid token addresses provided.");
    }

    const cacheKey = `tokenPrices:${chainId}:${tokenAddresses.join(",")}`;
    const cacheDuration = 5 * 60 * 1000; // Cache for 5 minutes

    // Check for cached prices
    if (cache.has(cacheKey)) {
        const { data, timestamp } = cache.get(cacheKey);
        if (Date.now() - timestamp < cacheDuration) {
            console.log("Returning cached token prices.");
            return data;
        }
    }

    // Batching logic: Split token addresses into smaller batches
    const batchSize = 10; // Adjust batch size based on API limits
    const tokenBatches = [];
    for (let i = 0; i < tokenAddresses.length; i += batchSize) {
        tokenBatches.push(tokenAddresses.slice(i, i + batchSize));
    }

    try {
        const allPrices = {};

        // Process each batch sequentially
        for (const batch of tokenBatches) {
            const addresses = batch.join(",");
            const url = `${PRICE_API_URL}/${chainId}/${addresses}`;

            // Fetch prices for the batch
            const response = await apiQueue.add(() =>
                axios.get(url, {
                    headers: HEADERS,
                })
            );

            const batchPrices = response.data;
            if (!batchPrices || Object.keys(batchPrices).length === 0) {
                throw new Error(`No prices returned for batch: ${addresses}`);
            }

            // Merge batch prices into allPrices
            Object.assign(allPrices, batchPrices);
        }

        if (Object.keys(allPrices).length === 0) {
            throw new Error("No prices returned for any tokens.");
        }

        // Cache the fetched prices
        cache.set(cacheKey, { data: allPrices, timestamp: Date.now() });
        console.log(`Fetched prices for ${Object.keys(allPrices).length} tokens.`);
        return allPrices;
    } catch (error) {
        console.error("Error fetching token prices:", error.message);

        // Optional fallback logic for individual token price fetching
        console.warn("Attempting fallback to individual token price fetching...");
        const fallbackPrices = {};
        for (const token of tokenAddresses) {
            try {
                const individualUrl = `${PRICE_API_URL}/${chainId}/${token}`;
                const response = await fetchWithRetry(individualUrl, {
                    headers: HEADERS,
                });

                if (response && response[token]) {
                    fallbackPrices[token] = response[token];
                    console.log(`Fetched individual price for token: ${token}`);
                } else {
                    console.warn(`Missing price data for token: ${token}`);
                }
            } catch (indError) {
                console.error(`Failed to fetch price for token: ${token}`, indError.message);
            }
        }

        if (Object.keys(fallbackPrices).length === 0) {
            console.error("Failed to fetch prices for all tokens. Returning empty object.");
        }

        return fallbackPrices;
    }
}


async function generatePermitBatchSignature(route) {
    // Example implementation: Fetch permit signatures for tokens in the route
    // Ensure `AllowanceTransfer` SDK or similar tools are imported
    const tokens = await Promise.all(
        route.map(async (token) => ({
            token,
            amount: CAPITAL.toFixed(),
            expiration: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // 24 hours
            nonce: await fetchNonce(process.env.WALLET_ADDRESS, token),
        }))
    );

    const permitBatch = {
        details: tokens,
        spender: CONTRACT_ADDRESS,
        sigDeadline: Math.floor(Date.now() / 1000) + 3600, // 1-hour signature validity
    };

    const { domain, types, values } = AllowanceTransfer.getPermitBatchData(
        permitBatch,
        process.env.PERMIT2_ADDRESS,
        chainId
    );

    return web3.eth.accounts.signTypedData(domain, types, values);
}


// Generate Multi-Hop Routes

/**
 * Generate profitable routes using 1inch Swap API
 */
async function generateRoutes(tokens = STABLE_TOKENS, maxHops = MAX_HOPS, startToken = "usdc") {
    const routes = [];
    const tokenPairs = new Set();

    // Fetch necessary data
    const tokenPrices = await fetchTokenPrices(tokens); // Fetch live token prices
    const historicalData = await fetchHistoricalData(tokens); // Fetch historical performance data
    const transactionHistory = await fetchTransactionHistory(process.env.WALLET_ADDRESS, chainId); // Fetch wallet transaction history
    const historicalGasPrices = await fetchHistoricalGasPrices(); // Fetch historical gas price trends
    const failedTokens = transactionHistory
        .filter((tx) => tx.status === "failed")
        .map((tx) => tx.tokenInAddress);
    const safeTokens = tokens.filter((token) => !failedTokens.includes(token));
    const availableTokens = await fetchAvailableTokens(); // Fetch tokens supported by 1inch API
    const averageGasPrice = calculateAverageGasPrice(historicalGasPrices); // Calculate historical average gas price
    const gasCostPerTrade = averageGasPrice.multipliedBy(800000); // Estimated gas cost
    const startTokenAddress = availableTokens.find((token) => token === startToken);

    if (!startTokenAddress) {
        console.error(`Start token ${startToken} not found in the token list.`);
        return [];
    }

    if (!tokenPrices[startToken]) {
        console.error("Token price for the start token is missing.");
        return [];
    }

    // Initialize a max-heap priority queue for routes based on potential profit
    const priorityQueue = new PriorityQueue((a, b) => b.potentialProfit.minus(a.potentialProfit).toNumber());

    // Seed the queue with the start token
    priorityQueue.enq({
        path: [startTokenAddress],
        remainingHops: maxHops,
        potentialProfit: new BigNumber(0),
    });

    while (!priorityQueue.isEmpty()) {
        const { path: currentPath, remainingHops } = priorityQueue.deq();

        if (remainingHops === 0) continue; // Skip if no hops are remaining

        const lastToken = currentPath[currentPath.length - 1];

        for (const nextToken of safeTokens) {
            if (nextToken === lastToken || currentPath.includes(nextToken)) continue;

            const newPath = [...currentPath, nextToken];
            const pairKey = `${lastToken}-${nextToken}`;

            if (!tokenPairs.has(pairKey)) {
                try {
                    // Use 1inch API to fetch best quote for the token pair
                    const quote = await fetchSwapQuote(lastToken, nextToken, CAPITAL);
                    if (!quote) {
                        console.warn(`No valid quote for pair ${lastToken} ➡️ ${nextToken}`);
                        continue;
                    }

                    const liquiditySources = await fetchLiquiditySources(); // Fetch available liquidity sources
                    const hasLiquidity = liquiditySources.some((source) => source.name === "1inch" && source.volume > CAPITAL);

                    if (!hasLiquidity) {
                        console.warn(`Insufficient liquidity for pair ${lastToken} ➡️ ${nextToken}`);
                        continue;
                    }

                    // Fetch live prices and calculate potential profit
                    const fromPrice = tokenPrices[lastToken] || new BigNumber(0);
                    const toPrice = new BigNumber(quote.toTokenAmount).dividedBy(1e18); // Assuming 18 decimals
                    const historicalTrend = calculateHistoricalTrend(historicalData, lastToken, nextToken);
                    const potentialProfit = toPrice.minus(fromPrice).multipliedBy(historicalTrend);

                    // Calculate a dynamic profit threshold
                    const threshold = dynamicThreshold(CAPITAL, gasCostPerTrade);

                    if (potentialProfit.isGreaterThan(threshold)) {
                        routes.push(newPath);

                        console.log(`Added route: ${lastToken} ➡️ ${nextToken}. Potential Profit: $${potentialProfit.dividedBy(1e6).toFixed(2)}`);
                        await sendTelegramMessage(`✅ Route Added: ${lastToken} ➡️ ${nextToken}.
Potential Profit: $${potentialProfit.dividedBy(1e6).toFixed(2)}.`);

                        // Enqueue the new path for further exploration
                        if (remainingHops > 1) {
                            priorityQueue.enq({
                                path: newPath,
                                remainingHops: remainingHops - 1,
                                potentialProfit,
                            });
                        }
                    } else {
                        console.log(`Skipped route ${lastToken} ➡️ ${nextToken}. Reason: Low liquidity or insufficient profit.`);
                        await sendTelegramMessage(`⚠️ Skipped Route: ${lastToken} ➡️ ${nextToken}.
Reason: Low liquidity or insufficient profit.
Potential Profit: $${potentialProfit.dividedBy(1e6).toFixed(2)}.`);
                    }
                } catch (error) {
                    console.error(`Error evaluating route ${lastToken} ➡️ ${nextToken}: ${error.message}`);
                }

                tokenPairs.add(pairKey); // Mark this pair as checked
            }
        }
    }

    if (routes.length === 0) {
        console.warn("No profitable routes generated.");
    }

    return routes;
}

/**
 * Fetch the best quote for a token pair from 1inch Swap API
 */
async function fetchSwapQuote(fromToken, toToken, amount) {
    try {
        const url = `${SWAP_API_URL}/${chainId}/quote`;
        const response = await axios.get(url, {
            headers: HEADERS,
            params: {
                fromTokenAddress: fromToken,
                toTokenAddress: toToken,
                amount: amount.toFixed(),
            },
        });
        return response.data;
    } catch (error) {
        console.error(`Failed to fetch swap quote for ${fromToken} ➡️ ${toToken}:`, error.message);
        return null;
    }
}

/**
 * Fetch available tokens from 1inch Swap API
 */
async function fetchAvailableTokens() {
    try {
        const url = `${SWAP_API_URL}/${chainId}/tokens`;
        const response = await axios.get(url, { headers: HEADERS });
        return Object.keys(response.data.tokens || {});
    } catch (error) {
        console.error("Failed to fetch available tokens:", error.message);
        return [];
    }
}

/**
 * Fetch liquidity sources from 1inch Swap API
 */
async function fetchLiquiditySources() {
    try {
        const url = `${SWAP_API_URL}/${chainId}/liquidity-sources`;
        const response = await axios.get(url, { headers: HEADERS });
        return response.data.protocols || [];
    } catch (error) {
        console.error("Failed to fetch liquidity sources:", error.message);
        return [];
    }
}

async function fetchHistoricalGasPrices() {
    try {
        const response = await apiQueue.add(() =>
            axios.get("https://api.blocknative.com/gasprices/blockprices", {
                headers: { Authorization: `Bearer ${process.env.BLOCKNATIVE_API_KEY}` },
                params: { chainId: 42161 }, // Arbitrum network
            })
        );

        // Validate response structure
        if (!response || !response.data || !response.data.blockPrices) {
            throw new Error("Invalid response structure or missing blockPrices data.");
        }

        // Extract historical gas prices and validate consistency
        const historicalGasPrices = response.data.blockPrices.map((block) => {
            if (!block.estimatedPrices || !block.estimatedPrices[0]?.price) {
                console.warn("Missing estimated price data for a block. Skipping.");
                return null;
            }
            return new BigNumber(block.estimatedPrices[0].price).shiftedBy(9); // Convert Gwei to Wei
        }).filter(Boolean); // Remove null or invalid entries

        // Ensure we have sufficient data
        if (historicalGasPrices.length < 5) { // Arbitrary threshold for "sufficient" data
            console.warn("Insufficient historical gas prices. Falling back to default trend.");
            return [new BigNumber(50).shiftedBy(9)]; // Fallback to default 50 Gwei if data is sparse
        }

        return historicalGasPrices;
    } catch (error) {
        console.error("Failed to fetch historical gas prices:", error.message);
        return [new BigNumber(50).shiftedBy(9)]; // Fallback to default 50 Gwei if API fails
    }
}

function calculateWeightedAverageGasPrice(historicalGasPrices) {
    if (historicalGasPrices.length === 0) {
        return new BigNumber(50).shiftedBy(9); // Default to 50 Gwei
    }

    // Assign higher weights to more recent prices
    const weights = historicalGasPrices.map((_, index) => index + 1); // Incremental weights
    const weightedSum = historicalGasPrices.reduce((sum, price, index) => {
        return sum.plus(price.multipliedBy(weights[index]));
    }, new BigNumber(0));

    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    return weightedSum.dividedBy(totalWeight); // Calculate the weighted average
}



// Utility function to fetch historical price data
async function fetchHistoricalData(tokens) {
    const historicalData = {};
    for (const token of tokens) {
        try {
            const response = await apiQueue.add(() =>
                axios.get(`https://api.somehistoricaldataprovider.com/prices`, {
                    headers: HEADERS,
                    params: { token, days: 30 },
                })
            );
            historicalData[token] = response.data; // Assume API provides historical data array
        } catch (error) {
            console.error(`Failed to fetch historical data for ${token}:`, error.message);
        }
    }
    return historicalData;
}

// Utility function to calculate historical trend
function calculateHistoricalTrend(historicalData, fromToken, toToken) {
    const fromTokenData = historicalData[fromToken] || [];
    const toTokenData = historicalData[toToken] || [];
    if (fromTokenData.length === 0 || toTokenData.length === 0) return 1; // Default to neutral trend

    const fromAvg = fromTokenData.reduce((sum, val) => sum + val, 0) / fromTokenData.length;
    const toAvg = toTokenData.reduce((sum, val) => sum + val, 0) / toTokenData.length;
    return toAvg / fromAvg; // Calculate relative trend ratio
}

function calculateAverageGasPrice(historicalGasPrices) {
    if (historicalGasPrices.length === 0) return new BigNumber(50).shiftedBy(9); // Default to 50 Gwei
    return historicalGasPrices.reduce((sum, price) => sum.plus(price), new BigNumber(0)).dividedBy(historicalGasPrices.length);
}

/**
 * Check liquidity for a given token pair
 */
async function checkLiquidity(pair) {
    const key = pair.join('-');
    if (liquidityCache[key]) {
        console.log(`Returning cached liquidity for pair ${pair.join(" ➡️ ")}`);
        return liquidityCache[key]; // Use cached liquidity if available
    }

    try {
        // Validate tokens via 1inch Tokens API
        const tokenValidation = await fetchAvailableTokens();
        if (!tokenValidation.includes(pair[0]) || !tokenValidation.includes(pair[1])) {
            console.warn(`One or both tokens in pair ${pair.join(" ➡️ ")} are not supported.`);
            return new BigNumber(0);
        }

        // Fetch the best quote for the token pair via 1inch Swap API
        const quoteResponse = await axios.get(`${SWAP_API_URL}/${chainId}/quote`, {
            headers: HEADERS,
            params: {
                fromTokenAddress: pair[0],
                toTokenAddress: pair[1],
                amount: CAPITAL.toFixed(), // Use the predefined capital amount for evaluation
            },
        });

        const quoteData = quoteResponse.data;
        if (!quoteData || !quoteData.toTokenAmount) {
            console.warn(`No valid quote available for pair ${pair.join(" ➡️ ")}`);
            return new BigNumber(0);
        }

        const availableLiquidity = new BigNumber(quoteData.toTokenAmount).dividedBy(1e18); // Adjust for token decimals

        // Fetch liquidity sources to validate available routing
        const liquiditySourcesResponse = await axios.get(`${SWAP_API_URL}/${chainId}/liquidity-sources`, {
            headers: HEADERS,
        });

        const liquiditySources = liquiditySourcesResponse.data.protocols || [];
        const isRoutable = liquiditySources.some((source) => source.name === "1inch" && source.volume > CAPITAL);

        if (!isRoutable) {
            console.warn(`Insufficient routable liquidity for pair ${pair.join(" ➡️ ")}`);
            return new BigNumber(0);
        }

        // Cache the validated liquidity for the pair
        liquidityCache[key] = availableLiquidity;
        console.log(`Liquidity for pair ${pair.join(" ➡️ ")}: ${availableLiquidity.toFixed(6)}`);
        return availableLiquidity;
    } catch (error) {
        console.error(`Error fetching liquidity for pair ${pair.join(" ➡️ ")}:`, error.message);
        return new BigNumber(0); // Default to 0 if API fails
    }
}

/**
 * Fetch available tokens from 1inch Swap API
 */
async function fetchAvailableTokens() {
    try {
        const url = `${SWAP_API_URL}/${chainId}/tokens`;
        const response = await axios.get(url, { headers: HEADERS });
        return Object.keys(response.data.tokens || {});
    } catch (error) {
        console.error("Failed to fetch available tokens:", error.message);
        return [];
    }
}

/**
 * Fetch token list from 1inch Swap API.
 * Filters tokens in STABLE_TOKENS and validates their support by the protocol.
 */

async function fetchTokenList() {
    const cacheKey = `tokenList:${chainId}`;
    const cacheDuration = 10 * 60 * 1000; // Cache for 10 minutes

    // Check cache for previously fetched token list
    if (cache.has(cacheKey)) {
        const { data, timestamp } = cache.get(cacheKey);
        if (Date.now() - timestamp < cacheDuration) {
            console.log("Returning cached token list.");
            return data;
        }
    }

    try {
        console.log(`Fetching token list for chain ID ${chainId}...`);

        // Call 1inch Swap API to retrieve supported tokens
        const response = await apiQueue.add(() =>
            axios.get(`${SWAP_API_URL}/${chainId}/tokens`, { headers: HEADERS })
        );

        const allTokens = response.data?.tokens;
        if (!allTokens || Object.keys(allTokens).length === 0) {
            throw new Error("No tokens returned from the 1inch Token API.");
        }

        // Filter to match tokens in the STABLE_TOKENS list
        const stableTokenDetails = STABLE_TOKENS.map((symbol) => {
            const token = Object.values(allTokens).find((t) => t.symbol.toLowerCase() === symbol.toLowerCase());
            if (!token) {
                console.warn(`Token ${symbol} is not supported by 1inch.`);
            }
            return token;
        }).filter(Boolean); // Remove null or undefined tokens

        if (stableTokenDetails.length === 0) {
            throw new Error("No stable tokens matched with the fetched token list.");
        }

        // Cache the filtered stable tokens
        cache.set(cacheKey, { data: stableTokenDetails, timestamp: Date.now() });

        console.log(`Fetched and validated ${stableTokenDetails.length} stable tokens.`);
        return stableTokenDetails;
    } catch (error) {
        console.error("Error fetching token list:", error.message);
        return [];
    }
}

async function getGasCostPerTrade() {
    const historicalGasPrices = await fetchHistoricalGasPrices();
    const averageGasPrice = calculateWeightedAverageGasPrice(historicalGasPrices);
    return averageGasPrice.multipliedBy(800000); // Adjusted gas estimation based on historical trends
}


async function calculatePriceVolatilityAdjustment(route) {
    try {
        // Fetch historical data for tokens in the route
        const historicalData = await fetchHistoricalData(route);

        let totalVolatility = 0;

        for (let i = 0; i < route.length - 1; i++) {
            const tokenA = route[i];
            const tokenB = route[i + 1];

            const tokenAData = historicalData[tokenA] || [];
            const tokenBData = historicalData[tokenB] || [];

            if (tokenAData.length === 0 || tokenBData.length === 0) {
                console.warn(`Missing historical data for pair: ${tokenA} -> ${tokenB}`);
                continue;
            }

            // Calculate percentage changes for each token
            const tokenAChanges = calculatePercentageChanges(tokenAData);
            const tokenBChanges = calculatePercentageChanges(tokenBData);

            // Combine percentage changes and calculate standard deviation
            const combinedChanges = [...tokenAChanges, ...tokenBChanges];
            const volatility = calculateStandardDeviation(combinedChanges);

            console.log(`Volatility for ${tokenA} -> ${tokenB}: ${volatility}`);
            totalVolatility += volatility;
        }

        // Adjust the penalty as a percentage of the trade amount
        const adjustment = totalVolatility * 0.01; // 1% of volatility as penalty
        console.log(`Total price volatility adjustment: $${adjustment.toFixed(2)}`);

        return new BigNumber(adjustment).shiftedBy(6); // Convert to 6 decimals
    } catch (error) {
        console.error("Error calculating price volatility adjustment:", error.message);
        return new BigNumber(0); // Default to no adjustment if error occurs
    }
}

function calculatePercentageChanges(prices) {
    const changes = [];
    for (let i = 1; i < prices.length; i++) {
        const change = ((prices[i] - prices[i - 1]) / prices[i - 1]) * 100;
        changes.push(change);
    }
    return changes;
}

function calculateStandardDeviation(changes) {
    const mean = changes.reduce((sum, value) => sum + value, 0) / changes.length;
    const variance = changes.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / changes.length;
    return Math.sqrt(variance);
}

function calculateSlippage(tradeAmount, liquidity) {
    try {
        // DEX fee, typically 0.3% (0.003)
        const dexFee = 0.003;

        // Handle cases where liquidity is too low to calculate slippage
        if (liquidity.isLessThan(tradeAmount)) {
            console.warn("Liquidity is less than the trade amount. Slippage may be high.");
            return new BigNumber(1); // Maximum slippage (100%)
        }

        // Calculate slippage based on trade amount and liquidity
        const liquidityImpact = tradeAmount.dividedBy(liquidity);

        // Total slippage includes DEX fee and liquidity impact
        const totalSlippage = dexFee + liquidityImpact.toNumber();

        console.log(`Calculated slippage: ${totalSlippage * 100}%`);
        return new BigNumber(totalSlippage);
    } catch (error) {
        console.error("Error calculating slippage:", error.message);
        return new BigNumber(0.05); // Default to 5% slippage in case of error
    }
}

/**
 * Fetch historical transaction data using 1inch History API.
 */
async function fetchTransactionHistory(address, chainId = 42161, limit = 100) {
    const url = `${HISTORY_API_URL}/${address}/events`;
    try {
        const response = await apiQueue.add(() =>
            axios.get(url, {
                headers: HEADERS,
                params: { chainId, limit },
            })
        );

        return response.data || [];
    } catch (error) {
        console.error("Error fetching transaction history:", error.message);
        return [];
    }
}

/**
 * Constructs parameters required for swap execution calldata.
 * Integrates 1inch Swap API to generate precise calldata.
 * @param {Array} route - Array of token addresses defining the swap route.
 * @param {BigNumber} amount - Amount of tokens to swap (in smallest units).
 * @param {BigNumber} slippage - Slippage tolerance in percentage (e.g., 0.01 for 1%).
 * @param {string} permitBatchSignature - Signature for batch permit (if applicable).
 * @returns {string} Encoded transaction parameters.
 */
async function constructParams(route, amount, slippage, permitBatchSignature) {
    try {
        // Validate route
        if (route.length < 2) {
            throw new Error("Invalid route: A valid route must include at least two tokens.");
        }

        // Fetch calldata using 1inch Swap API
        const swapResponse = await axios.get(`${SWAP_API_URL}/${chainId}/swap`, {
            headers: HEADERS,
            params: {
                fromTokenAddress: route[0], // Source token address
                toTokenAddress: route[route.length - 1], // Destination token address
                amount: amount.toFixed(), // Token amount to swap
                fromAddress: CONTRACT_ADDRESS, // Contract address initiating the swap
                slippage: slippage.times(100).toFixed(), // Convert slippage to percentage (e.g., 1% = 1.00)
                disableEstimate: true, // Skip estimation to save gas and improve efficiency
            },
        });

        // Validate response
        const swapTxData = swapResponse.data?.tx;
        if (!swapTxData || !swapTxData.data) {
            throw new Error("Failed to generate swap transaction data from 1inch API.");
        }

        console.log("Swap calldata generated successfully from 1inch API.");

        // Construct swap description
        const swapDescription = {
            srcToken: route[0],
            dstToken: route[route.length - 1],
            srcReceiver: CONTRACT_ADDRESS,
            dstReceiver: CONTRACT_ADDRESS,
            amount: amount.toFixed(),
            minReturnAmount: amount.minus(amount.times(slippage)).toFixed(), // Adjusted for slippage
            flags: 0x04, // Use flags as needed for specific contract logic
        };

        // Encode parameters for contract execution
        const encodedParams = web3.eth.abi.encodeParameters(
            [
                'tuple(address srcToken, address dstToken, address srcReceiver, address dstReceiver, uint256 amount, uint256 minReturnAmount, uint256 flags)',
                'bytes', // Permit batch signature
                'bytes', // Route data (if applicable, use null for direct swaps)
            ],
            [Object.values(swapDescription), permitBatchSignature, swapTxData.data]
        );

        console.log("Encoded parameters constructed successfully.");
        return encodedParams;
    } catch (error) {
        console.error("Error constructing parameters for swap execution:", error.message);
        throw new Error(`Failed to construct parameters: ${error.message}`);
    }
}

// Execute Route
/**
 * Executes a profitable trade route by generating and sending calldata for swaps.
 */
async function executeRoute(route, amount, fallbackRoutes = [], attempts = 0) {
    const MAX_FALLBACK_ATTEMPTS = 3; // Maximum number of retries for fallback routes

    try {
        // Fetch transaction history to analyze high-fee tokens
        const history = await fetchTransactionHistory(process.env.WALLET_ADDRESS, chainId);
        const highFeeTokens = history
            .filter((tx) => tx.gasFee > MIN_PROFIT_THRESHOLD)
            .map((tx) => tx.tokenInAddress);

        // Exclude tokens with high fees
        for (const token of route) {
            if (highFeeTokens.includes(token)) {
                console.error(`Skipping execution due to high fees for token: ${token}`);
                await sendTelegramMessage(`⚠️ Skipping execution for route due to high fees for token: ${token}`);
                return;
            }
        }

        // Validate tokens in the route
        const invalidTokens = route.filter((token) => !STABLE_TOKENS.includes(token));
        if (invalidTokens.length > 0) {
            console.error(`Invalid tokens in route: ${invalidTokens.join(", ")}. Skipping execution.`);
            await sendTelegramMessage(`⚠️ Invalid Tokens in Route: ${invalidTokens.join(", ")}. Execution skipped.`);
            throw new Error("Invalid tokens in route.");
        }

        // Check liquidity for the first token pair
        const liquidity = await checkLiquidity([route[0], route[1]]);
        if (liquidity.isLessThan(CAPITAL)) {
            console.error(`Insufficient liquidity for pair ${route[0]} ➡️ ${route[1]}.`);
            await sendTelegramMessage(`⚠️ Insufficient Liquidity: ${route[0]} ➡️ ${route[1]}. Execution skipped.`);
            throw new Error("Insufficient liquidity.");
        }

        // Generate token approval calldata if needed
        const spenderAddressResponse = await axios.get(`${SWAP_API_URL}/${chainId}/approve/spender`, { headers: HEADERS });
        const spender = spenderAddressResponse.data?.address;

        for (const token of route) {
            const allowanceResponse = await axios.get(`${SWAP_API_URL}/${chainId}/approve/allowance`, {
                headers: HEADERS,
                params: { tokenAddress: token, walletAddress: process.env.WALLET_ADDRESS },
            });

            const allowance = new BigNumber(allowanceResponse.data?.allowance || 0);
            if (allowance.isLessThan(amount)) {
                console.log(`Generating approve transaction for token: ${token}`);
                const approveTransactionResponse = await axios.get(`${SWAP_API_URL}/${chainId}/approve/transaction`, {
                    headers: HEADERS,
                    params: { tokenAddress: token, amount: amount.toFixed() },
                });

                const approveTx = approveTransactionResponse.data;
                const signedApproveTx = await web3.eth.accounts.signTransaction(
                    approveTx,
                    process.env.PRIVATE_KEY
                );
                await web3.eth.sendSignedTransaction(signedApproveTx.rawTransaction);
                console.log(`Token ${token} approved for spender: ${spender}`);
            }
        }

        // Generate calldata for the swap
        const swapResponse = await axios.get(`${SWAP_API_URL}/${chainId}/swap`, {
            headers: HEADERS,
            params: {
                fromTokenAddress: route[0],
                toTokenAddress: route[route.length - 1],
                amount: amount.toFixed(),
                fromAddress: process.env.WALLET_ADDRESS,
                slippage: 1, // Adjust slippage tolerance as needed (e.g., 1%)
                disableEstimate: true, // To improve efficiency
            },
        });

        const swapTxData = swapResponse.data?.tx;
        if (!swapTxData) {
            throw new Error("Failed to generate swap transaction data.");
        }

        // Validate profitability before execution
        const gasEstimate = await web3.eth.estimateGas({
            from: process.env.WALLET_ADDRESS,
            to: swapTxData.to,
            data: swapTxData.data,
        });
        const gasPrice = await fetchGasPrice().catch(() => new BigNumber(50).shiftedBy(9)); // Default to 50 Gwei
        const gasCost = new BigNumber(gasEstimate).multipliedBy(gasPrice);

        const projectedProfit = amount.minus(gasCost).minus(amount.multipliedBy(slippage));
        if (projectedProfit.isLessThan(MIN_PROFIT_THRESHOLD)) {
            console.error(`Route execution aborted: Insufficient profit after gas costs and slippage.
Projected Profit: $${projectedProfit.dividedBy(1e6).toFixed(2)}`);
            await sendTelegramMessage(`⚠️ Route Execution Skipped: ${route.join(" ➡️ ")}. Reason: Insufficient profit.`);
            throw new Error("Insufficient profit after gas costs and slippage.");
        }

        // Execute the swap transaction
        const signedSwapTx = await web3.eth.accounts.signTransaction(
            {
                from: process.env.WALLET_ADDRESS,
                to: swapTxData.to,
                data: swapTxData.data,
                gas: gasEstimate.toFixed(),
                gasPrice: gasPrice.toFixed(),
            },
            process.env.PRIVATE_KEY
        );
        const receipt = await web3.eth.sendSignedTransaction(signedSwapTx.rawTransaction);

        // Log success and notify
        console.log(`Transaction successful: ${receipt.transactionHash}`);
        await sendTelegramMessage(`✅ Trade Executed: ${route.join(" ➡️ ")}.
Transaction Hash: ${receipt.transactionHash}`);
    } catch (error) {
        console.error(`Error executing route: ${error.message}`);
        await sendTelegramMessage(`❌ Trade Failed: ${route.join(" ➡️ ")}. Error: ${error.message}`);

        // Retry fallback routes if available
        if (fallbackRoutes.length > 0 && attempts < MAX_FALLBACK_ATTEMPTS) {
            fallbackRoutes.sort((a, b) => b.potentialProfit.minus(a.potentialProfit).toNumber());
            const nextRoute = fallbackRoutes.shift();
            console.log(`Retrying with fallback route: ${nextRoute.path.join(" ➡️ ")}.`);
            return await executeRoute(nextRoute.path, amount, fallbackRoutes, attempts + 1);
        }

        console.error("No fallback routes available or maximum attempts reached. Execution terminated.");
        await sendTelegramMessage(`❌ All fallback routes exhausted. Execution terminated.`);
    }
}


// Main Function
async function startArbitrageBot() {
    console.log("Starting arbitrage bot...");

    const interval = 60000; // Default interval in milliseconds
    const errorCooldown = 300000; // 5 minutes cooldown on critical errors

    setInterval(async () => {
        try {
            console.log("Fetching token prices...");
            const tokenPrices = await fetchTokenPrices(STABLE_TOKENS);

            if (Object.keys(tokenPrices).length < STABLE_TOKENS.length) {
                console.error("Incomplete token prices. Skipping this iteration.");
                await sendTelegramMessage("⚠️ Incomplete token prices fetched. Skipping arbitrage loop.");
                return;
            }

            console.log("Generating profitable routes...");
            const routes = await generateRoutes(Object.keys(tokenPrices), MAX_HOPS, "usdc", tokenPrices);

            if (routes.length === 0) {
                console.log("No profitable routes found.");
                await sendTelegramMessage("⚠️ No profitable routes found in this iteration.");
                return;
            }

            // Process routes with fallback mechanism
            await processRoutesWithFallback(routes, CAPITAL);
        } catch (error) {
            console.error("Critical error in arbitrage loop:", error);
            await sendTelegramMessage(`❌ Critical Arbitrage Bot Error: ${error.message}`);

            // Cooldown to avoid frequent retries on critical failures
            console.log(`Pausing bot for ${errorCooldown / 60000} minutes due to errors.`);
            setTimeout(() => console.log("Resuming arbitrage bot..."), errorCooldown);
        }
    }, interval);
}

/**
 * Processes routes and handles fallback routes when primary routes fail.
 * Integrates 1inch Swap API to dynamically adapt and ensure swap execution.
 * @param {Array} routes - Array of routes to process.
 * @param {BigNumber} amount - Amount to trade (in smallest units).
 */
async function processRoutesWithFallback(routes, amount) {
    if (routes.length === 0) {
        console.error("No routes available for execution.");
        await sendTelegramMessage("⚠️ No routes available for execution.");
        return;
    }

    const MAX_FALLBACK_ATTEMPTS = 3; // Define maximum fallback attempts

    // Analyze historical transaction data to prioritize successful routes
    const history = await fetchTransactionHistory(process.env.WALLET_ADDRESS, chainId);
    const successfulRoutes = history
        .filter((tx) => tx.status === "success")
        .map((tx) => tx.path);

    // Create a fallback queue with prioritized routes
    const fallbackRoutes = routes.slice(1).map((route) => ({
        path: route,
        potentialProfit: calculatePotentialProfit(route), // Calculate potential profit for each route
        successRate: successfulRoutes.filter((sr) => sr.join('-') === route.join('-')).length, // Historical success metric
    }));

    // Sort fallback routes by potential profit and success rate
    fallbackRoutes.sort((a, b) => {
        const profitComparison = b.potentialProfit.minus(a.potentialProfit).toNumber();
        return profitComparison !== 0 ? profitComparison : b.successRate - a.successRate;
    });

    console.log(`Processing ${routes.length} routes with fallback enabled.`);

    try {
        // Execute the best route with fallback options
        await executeRoute(routes[0], amount, fallbackRoutes);
    } catch (primaryError) {
        console.error("Failed to execute primary route. Attempting fallbacks if available.", primaryError.message);

        let attempts = 0; // Track fallback attempts

        for (const fallbackRoute of fallbackRoutes) {
            if (attempts >= MAX_FALLBACK_ATTEMPTS) {
                console.error("Maximum fallback attempts reached. Halting retries.");
                await sendTelegramMessage("❌ Maximum fallback attempts reached. Execution terminated.");
                break;
            }

            try {
                // Validate allowances for the fallback route
                await validateAllowances(fallbackRoute.path);

                // Fetch best quote for the fallback route
                const quote = await fetchBestQuote(fallbackRoute.path, amount);
                if (!quote) {
                    console.warn(`No valid quote found for fallback route: ${fallbackRoute.path.join(" ➡️ ")}.`);
                    continue;
                }

                console.log(`Attempting fallback route: ${fallbackRoute.path.join(" ➡️ ")}.`);
                await executeRoute(fallbackRoute.path, amount);
                console.log(`Fallback route executed successfully: ${fallbackRoute.path.join(" ➡️ ")}.`);
                return; // Exit function on successful execution
            } catch (fallbackError) {
                console.error(`Failed to execute fallback route: ${fallbackRoute.path.join(" ➡️ ")}.`, fallbackError.message);
                attempts++;
            }
        }

        console.error("All fallback routes exhausted. No successful execution.");
        await sendTelegramMessage("❌ All fallback routes failed. No successful execution.");
    }
}

async function fetchBestQuote(route, amount) {
    try {
        const response = await axios.get(`${SWAP_API_URL}/${chainId}/quote`, {
            headers: HEADERS,
            params: {
                fromTokenAddress: route[0],
                toTokenAddress: route[route.length - 1],
                amount: amount.toFixed(),
            },
        });

        return response.data; // Return the best quote data
    } catch (error) {
        console.error(`Failed to fetch quote for route: ${route.join(" ➡️ ")}.`, error.message);
        return null;
    }
}

async function validateAllowances(route) {
    try {
        for (const token of route) {
            const response = await axios.get(`${SWAP_API_URL}/${chainId}/approve/allowance`, {
                headers: HEADERS,
                params: { tokenAddress: token, walletAddress: process.env.WALLET_ADDRESS },
            });

            if (new BigNumber(response.data.allowance).isLessThan(CAPITAL)) {
                throw new Error(`Insufficient allowance for token: ${token}`);
            }
        }
        console.log("All token allowances validated successfully.");
    } catch (error) {
        console.error("Allowance validation failed:", error.message);
        throw error;
    }
}

console.log(`Profit Calculation:
    - Amount: $${amount.dividedBy(1e6).toFixed(2)}
    - Gas Cost: $${gasCost.dividedBy(1e9).toFixed(2)}
    - Slippage: ${slippage.toFixed(2)}%
    - Price Volatility Adjustment: $${priceVolatilityAdjustment.dividedBy(1e6).toFixed(2)}
    - Projected Profit: $${projectedProfit.dividedBy(1e6).toFixed(2)}
`);

async function handleExecutionError(error, route) {
    console.error(`Execution error for route: ${route.join(" ➡️ ")} - ${error.message}`);
    await sendTelegramMessage(`❌ Error Executing Route: ${route.join(" ➡️ ")}. Reason: ${error.message}`);
}

startArbitrageBot();
